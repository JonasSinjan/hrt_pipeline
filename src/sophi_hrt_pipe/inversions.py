import numpy as np
from astropy.io import fits
from sophi_hrt_pipe.utils import *
from sophi_hrt_pipe.processes import data_hdr_kw
import os
import time
import subprocess
import datetime
import pymilos

def create_output_filenames(filename, DID, version = '01',gzip = False):
    """Creating the L2 output filenames from the input file, which is assumed to be L1

    Parameters
    ----------
    filename : str
        The input filename (L1 assumed)
    DID : str
        The Dataset ID (DID) of the input file
    version : str, optional
        The version of the output file, by default '01'
    gzip : bool, optional
        Whether the output file is gzipped, by default False

    Returns
    -------
    stokes_file : str
        The output filename for the Stokes parameters
    icnt_file : str
        The output filename for the continuum intensity
    bmag_file : str
        The output filename for the magnetic field magnitude
    bazi_file : str
        The output filename for the magnetic field azimuth
    binc_file : str
        The output filename for the magnetic field inclination
    blos_file : str
        The output filename for the magnetic field line-of-sight component
    vlos_file : str
        The output filename for the line-of-sight velocity
    """
    file_start = 'solo_L2_phi-hrt-ilam_'
    fmt = "%Y%m%dT%H%M%S"
    
    try:
        temp = time.strftime(fmt,time.strptime(fits.getheader(filename)['DATE-BEG'],'%Y-%m-%dT%H:%M:%S.%f'))
    except Exception:
        temp = 'YYYYmmddTHHMMSS'
        print(f"The input file: {filename} does not contain DATE-BEG keyword: using {temp}")
    
    versioned = file_start + temp + '_V' + version + '_' + DID + '.fits'
    if gzip:
        versioned = versioned + '.gz'
    stokes_file = versioned.replace('ilam', 'stokes')
    icnt_file = versioned.replace('ilam', 'icnt')
    bmag_file = versioned.replace('ilam', 'bmag')
    bazi_file = versioned.replace('ilam', 'bazi')
    binc_file = versioned.replace('ilam', 'binc')
    blos_file = versioned.replace('ilam', 'blos')
    vlos_file = versioned.replace('ilam', 'vlos')
    chi2_file = versioned.replace('ilam', 'chi2')
    
    return stokes_file, icnt_file, bmag_file, bazi_file, binc_file, blos_file, vlos_file, chi2_file


def write_output_inversion(rte_data_products, file_path, scan, hdr_scan, out_dir, out_rte_filename, vers):
    """Write out the L2 files (excluding the Stokes parameters)
    
    Parameters
    ----------
    rte_data_products : np.ndarray
        The RTE data products generated by C-MILOS
    file_path : str
        The input filename (L1 assumed) of the science data
    scan : int
        The scan number
    hdr_scan : astropy.io.fits.header.Header
        The header of the science data
    out_dir : str
        The output directory
    out_rte_filename : str or list
        The output filename(s) for the RTE data products, if None, the output filename will be generated with `create_output_filenames`
    vers : str
        The version of the output file

    Returns
    -------
    None
    """
    if out_rte_filename is None:
            filename_root = str(file_path.split('.fits')[0][-10:])
            if ".gz" in file_path:
                gzip = True
            else:
                gzip = False
            _, icnt_file, bmag_file, bazi_file, binc_file, blos_file, vlos_file, chi2_file = create_output_filenames(file_path, filename_root, version = vers, gzip = gzip)

    else:
        if isinstance(out_rte_filename, list):
            filename_root = out_rte_filename[scan]

        elif isinstance(out_rte_filename, str):
            filename_root = out_rte_filename

        else:
            filename_root = str(file_path.split('.fits')[0][-10:])
            print(f"out_rte_filename neither string nor list, reverting to default: {filename_root}")

        blos_file, icnt_file, bmag_file, bazi_file, binc_file, vlos_file, chi2_file = 'blos_' + filename_root, 'icnt_' + filename_root, 'bmag_' + filename_root, 'bazi_' + filename_root, 'binc_' + filename_root, 'vlos_' + filename_root, 'chi2_' + filename_root

    ntime = datetime.datetime.now()
    hdr_scan['DATE'] = ntime.strftime("%Y-%m-%dT%H:%M:%S")

    version_k = hdr_scan['VERS_SW']
    if '.fits' in hdr_scan['CAL_DARK']:
        dark_f_k = 'True'
    else:
        dark_f_k = 'False'
    if '.fits' in hdr_scan['CAL_FLAT']:
        flat_f_k = 'True'
    else:
        flat_f_k = 'False'
    clean_f_k = hdr_scan['CAL_USH']
    if hdr_scan['CAL_CRT1'] > 0:
        ItoQUV_k ='True'
    else:
        ItoQUV_k = 'False'
    rte_sw_k = hdr_scan['RTE_SW']
    rte_mod_k = hdr_scan['RTE_MOD']

    with fits.open(file_path) as hdu_list:
        hdu_list[0].header = hdr_scan
        hdu_list[0].data = rte_data_products.astype(np.float32)
        hdu_list.writeto(out_dir+filename_root+'_rte_data_products.fits.gz', overwrite=True)
	
    #blos
    print(blos_file, bmag_file, binc_file)
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = blos_file
        hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'BLOS'
        hdr_scan['BUNIT'] = 'Gauss'
        hdr_scan['DATAMIN'] = int(np.min(rte_data_products[5,:,:]))
        hdr_scan['DATAMAX'] = int(np.max(rte_data_products[5,:,:]))
        hdr_scan = data_hdr_kw(hdr_scan, rte_data_products[5,:,:])

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = rte_data_products[5,:,:].astype(np.float32)
        hdu_list.writeto(out_dir+blos_file, overwrite=True)

    #bazi
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = bazi_file
        hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'BAZI'
        hdr_scan['BUNIT'] = 'Degrees'
        hdr_scan['DATAMIN'] = int(0)
        hdr_scan['DATAMAX'] = int(180)
        hdr_scan = data_hdr_kw(hdr_scan, rte_data_products[3,:,:])

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = rte_data_products[3,:,:].astype(np.float32)
        hdu_list.writeto(out_dir+bazi_file, overwrite=True)

    #binc
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = binc_file
        hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'BINC'
        hdr_scan['BUNIT'] = 'Degrees'
        hdr_scan['DATAMIN'] = int(0)
        hdr_scan['DATAMAX'] = int(180)
        hdr_scan = data_hdr_kw(hdr_scan, rte_data_products[2,:,:])

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = rte_data_products[2,:,:].astype(np.float32)
        hdu_list.writeto(out_dir+binc_file, overwrite=True)

    #bmag
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = bmag_file
        hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'BMAG'
        hdr_scan['BUNIT'] = 'Gauss'
        hdr_scan['DATAMIN'] = int(0)
        hdr_scan['DATAMAX'] = round(np.max(rte_data_products[1,:,:]),3)
        hdr_scan = data_hdr_kw(hdr_scan, rte_data_products[1,:,:])

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = rte_data_products[1,:,:].astype(np.float32)
        hdu_list.writeto(out_dir+bmag_file, overwrite=True)

    #vlos
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = vlos_file
        hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'VLOS'
        hdr_scan['BUNIT'] = 'km/s'
        hdr_scan['DATAMIN'] = round(np.min(rte_data_products[4,:,:]),6)
        hdr_scan['DATAMAX'] = round(np.max(rte_data_products[4,:,:]),6)
        hdr_scan = data_hdr_kw(hdr_scan, rte_data_products[4,:,:])

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = rte_data_products[4,:,:].astype(np.float32)
        hdu_list.writeto(out_dir+vlos_file, overwrite=True)
    
    #chi2
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = chi2_file
        hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'CHI2'
        hdr_scan['BUNIT'] = ' '
        hdr_scan['DATAMIN'] = round(np.min(rte_data_products[6,:,:]),6)
        hdr_scan['DATAMAX'] = round(np.max(rte_data_products[6,:,:]),6)
        hdr_scan = data_hdr_kw(hdr_scan, rte_data_products[6,:,:])

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = rte_data_products[6,:,:].astype(np.float32)
        hdu_list.writeto(out_dir+chi2_file, overwrite=True)

    #Icnt
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = icnt_file
        hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'ICNT'
        hdr_scan['BUNIT'] = 'Normalised Intensity'
        hdr_scan['DATAMIN'] = 0
        hdr_scan['DATAMAX'] = round(np.max(rte_data_products[0,:,:]),6)
        hdr_scan = data_hdr_kw(hdr_scan, rte_data_products[0,:,:])

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = rte_data_products[0,:,:].astype(np.float32)
        hdu_list.writeto(out_dir+icnt_file, overwrite=True)


def run_cmilos(data,wave_axis,rte,cpos,options = [6,15],cavity_f = None, rows = slice(0,2048), cols = slice(0,2048), out_dir = './'):
    """RTE inversion using CMILOS

    Parameters
    ----------
    data : ndarray
        4D array of data (y,x,p,l) where y and x are the spatial dimensions, p the number of polarisation channels and l is is the spectral dimension. 
    wave_axis : ndarray
        1D array of wavelengths in Angstroms
    rte : str
        RTE inversion method to use. Options are 'RTE' or 'CE' or 'CE+RTE'. RTE = Radiative Transfer Equation inversion, CE = Classical Estimates, CE+RTE = Classical Estimates as initial condition for RTE
    cpos : int
        continuum position in the spectral dimension. 0 = blue, 5 = red
    options : list, optional
        list of options for RTE inversion. The default is [6,15]. First element is the number of wavelengths in each scan, Second is the max number of iterations.
    cavity_f : str, optional
        path to cavity map fits file. The default is None.
    rows : slice, optional
        slice of rows to use. The default is slice(0,2048).
    cols : slice, optional
        slice of columns to use. The default is slice(0,2048).
    out_dir : str, optional
        path to output directory. The default is './'.

    Returns
    -------
    rte_data_products : ndarray
        3D array of RTE inversion products (r,y,x) where r are the 12 output parameters, y and x are the spatial dimensions
        r from 0 to 11:
            Counter (PX Id)
            Iterations
            Strength
            Inclination
            Azimuth
            Eta0 parameter
            Doppler width
            Damping
            Los velocity
            Constant source function
            Slope source function
            Minimum chisqr value
    """
    print(" ")
    printc('-->>>>>>> RUNNING CMILOS ',color=bcolors.OKGREEN)
    
    try:
        CMILOS_LOC = os.path.realpath(__file__)

        CMILOS_LOC = CMILOS_LOC.split('src/')[0] + 'cmilos/' #-11 as hrt_pipe.py is 11 characters

        if os.path.isfile(CMILOS_LOC+'milos'):
            printc("Cmilos executable located at:", CMILOS_LOC,color=bcolors.WARNING)

        else:
            raise ValueError('Cannot find cmilos:', CMILOS_LOC)

    except ValueError as err:
        printc(err.args[0],color=bcolors.FAIL)
        printc(err.args[1],color=bcolors.FAIL)
        return        

    wavelength = 6173.3354

    start_time = time.perf_counter()

    if cpos == 0:
        shift_w =  wave_axis[3] - wavelength
    elif cpos == 5:
        shift_w =  wave_axis[2] - wavelength
    # DC TEST
    else:
        
        shift_w = 0.0
    wave_axis = wave_axis - shift_w

    print('It is assumed the wavelength array is given by the hdr')
    #print(wave_axis,color = bcolors.WARNING)
    print("Wave axis is: ", (wave_axis - wavelength)*1000.)
    print('Saving data into dummy_in.txt for RTE input')

    if data.ndim == 4:
        sdata = data
    elif data.ndim != 4:
        print("Incorrect dimensions of 'data' array")
        exit()
    y,x,p,l = sdata.shape
    #print(y,x,p,l)
    
    filename = out_dir + 'dummy_in.txt'

    if cavity_f is not None:
        printc("  ---- >>>>> Correcting wavelengths for Cavity Maps shifts: .... ",color=bcolors.OKGREEN)
        wave_axis_2d = cavity_shifts(cavity_f,wave_axis,rows,cols)
    else:
        wave_axis_2d = np.zeros((y,x,1)) + wave_axis[np.newaxis,np.newaxis]
        
    with open(filename,"w") as f:
        for i in range(x):
            for j in range(y):
                for k in range(l):
                    f.write('%e %e %e %e %e \n' % (wave_axis_2d[j,i,k],sdata[j,i,0,k],sdata[j,i,1,k],sdata[j,i,2,k],sdata[j,i,3,k])) #wv, I, Q, U, V

    printc(f'  ---- >>>>> Inverting data: .... ',color=bcolors.OKGREEN)

    cmd = CMILOS_LOC+"./milos"
    cmd = fix_path(cmd)

    if rte == 'RTE':
        rte_on = subprocess.call(cmd+" "+str(options[0])+" "+str(options[1])+f" 0 0 {out_dir+'dummy_in.txt'}  >  {out_dir+'dummy_out.txt'}",shell=True)
    if rte == 'CE':
        rte_on = subprocess.call(cmd+" "+str(options[0])+" "+str(options[1])+f" 2 0 {out_dir+'dummy_in.txt'}  >  {out_dir+'dummy_out.txt'}",shell=True)
    if rte == 'CE+RTE':
        rte_on = subprocess.call(cmd+" "+str(options[0])+" "+str(options[1])+f" 1 0 {out_dir+'dummy_in.txt'}  >  {out_dir+'dummy_out.txt'}",shell=True)

    printc('  ---- >>>>> Reading results.... ',color=bcolors.OKGREEN)
    del_dummy = subprocess.call(f"rm {out_dir + 'dummy_in.txt'}",shell=True)

    res = np.loadtxt(out_dir+'dummy_out.txt')
    result = np.zeros((12,y*x)).astype(float)
    for i in range(y*x):
        result[:,i] = res[i*12:(i+1)*12]
    result = result.reshape(12,x,y)
    result = np.einsum('ijk->ikj', result)
    _ = subprocess.call(f"rm {out_dir+'dummy_out.txt'}",shell=True)
    
    printc(f"CMILOS RTE Inversion Run Time: {np.round(time.perf_counter() - start_time,3)} seconds ",bcolors.OKGREEN)
    
    return result

def cmilos(data_f, hdr_arr, wve_axis_arr, data_shape, cpos_arr, data, rte, mask, imgdirx_flipped, out_rte_filename, out_dir, cavity_f = None, rows = slice(0,2048), cols = slice(0,2048), vers = '01'):
    """Loop through scans in data_f, pre-processing and calls run_cmilos for each scan - writes out output files for each scan

    Parameters
    ----------
    data_f : list
        list of file paths to each science scan
    hdr_arr : list
        list of header information for each science scan
    wve_axis_arr : list or ndarray
        list of wavelength axis for each science scan
    data_shape : tuple
        shape of data array
    cpos_arr : list or ndarray
        list of cpos for each science scan
    data : ndarray
        data array
    rte : str
        RTE inversion method to use. Options are 'RTE' or 'CE' or 'CE+RTE'. RTE = Radiative Transfer Equation inversion, CE = Classical Estimates, CE+RTE = Classical Estimates as initial condition for RTE
    mask : ndarray
        mask array
    imgdirx_flipped : bool
        whether the image direction is flipped
    out_rte_filename : str
        output file name for RTE inversion, for standard, set to None
    out_dir : str
        output directory for RTE inversion
    cavity_f : str, optional
        cavity file path, by default None
    rows : slice, optional
        rows to use for RTE inversion, by default slice(0,2048)
    cols : slice, optional
        columns to use for RTE inversion, by default slice(0,2048)
    vers : str, optional

    Returns
    -------
    None
    """
    for scan in range(int(data_shape[-1])):
        printc(f'  ---- >>>>> Data scan number: {scan} .... ',color=bcolors.OKGREEN)
        
        start_time = time.perf_counter()

        file_path = data_f[scan]
        wave_axis = wve_axis_arr[scan]
        hdr_scan = hdr_arr[scan]
        
        if data.ndim == 5:
            sdata = data[:,:,:,:,scan]
        elif data.ndim > 5 or data.ndim < 4:
            print("Incorrect dimensions of 'data' array")
            exit()
        elif data.ndim == 4:
            sdata = data       
        #must invert each scan independently, as cmilos only takes in one dataset at a time
        #get wave_axis from the hdr information of the science scans - hard code first one, as must all same cpos as the first scan
        
        options = [6,15] # # of wavelegths, # of iterations
        
        rte_invs = run_cmilos(sdata,wave_axis,rte,cpos_arr[0],options,cavity_f,rows,cols,out_dir)
        
        rte_invs_noth = np.copy(rte_invs)

        """
        From 0 to 11
        Counter (PX Id)
        Iterations
        Strength
        Inclination
        Azimuth
        Eta0 parameter
        Doppler width
        Damping
        Los velocity
        Constant source function
        Slope source function
        Minimum chisqr value
        """

        noise_in_V =  np.mean(sdata[:,:,3,cpos_arr[0]]) #ellipsis in case data has 4 dimensions
        low_values_flags = np.max(np.abs(sdata[:,:,3,:]),axis=-1) < noise_in_V  # Where values are low
        
        del sdata

        rte_invs[2,low_values_flags] = 0
        rte_invs[3,low_values_flags] = 0
        rte_invs[4,low_values_flags] = 0

        rte_data_products = np.zeros((7,rte_invs_noth.shape[1],rte_invs_noth.shape[2]))

        rte_data_products[0,:,:] = rte_invs_noth[9,:,:] + rte_invs_noth[10,:,:] #continuum
        rte_data_products[1,:,:] = rte_invs_noth[2,:,:] #b mag strength
        rte_data_products[2,:,:] = rte_invs_noth[3,:,:] #inclination
        rte_data_products[3,:,:] = rte_invs_noth[4,:,:] #azimuth
        rte_data_products[4,:,:] = rte_invs_noth[8,:,:] #vlos
        rte_data_products[5,:,:] = rte_invs_noth[2,:,:]*np.cos(rte_invs_noth[3,:,:]*np.pi/180.) #blos
        rte_data_products[6,:,:] = rte_invs_noth[11,:,:] #chi2

        rte_data_products *= mask[np.newaxis, :, :, scan] #field stop, set outside to 0

        hdr_scan['RTE_MOD'] = rte
        hdr_scan['RTE_SW'] = 'cmilos'
        hdr_scan['RTE_ITER'] = str(15)

        write_output_inversion(rte_data_products, file_path, scan, hdr_scan, out_dir, out_rte_filename, vers)
            
        printc('--------------------------------------------------------------',bcolors.OKGREEN)
        printc(f"------------- CMILOS RTE Run Time: {np.round(time.perf_counter() - start_time,3)} seconds ",bcolors.OKGREEN)
        printc('--------------------------------------------------------------',bcolors.OKGREEN)

def run_pymilos(data,wave_axis,rte,cpos,options = np.asarray([6,15,0,0]),cavity_f = None, rows = slice(0,2048), cols = slice(0,2048),weight=np.asarray([1.,4.,5.4,4.1]),initial_model=np.asarray([400,30,120,1,0.05,1.5,.01,.22,.85])):
    """Run RTE inversion using `pymilos`: CMILOS with python wrapper for faster I/O
    Make sure to compile pymilos, see `pymilos` documentation for more details

    Parameters
    ----------
    data : numpy array
        4D array of data with dimensions (y,x,4,6) where 4 is the number of polarizations and 6 is the number of wavelengths
    wave_axis : numpy array or list
        1D array of wavelengths in Angstroms
    rte : str
        RTE inversion type. Options are 'RTE', 'CE', 'CE+RTE', 'RTE' is Radiative Transfer Equation inversion, 'CE' is Classical Estiamtes, 'CE+RTE' is Classical Estimates as initial condition for Radiative Transfer Equation inversion
    cpos : int or slice
        continuum position in the wavelength array
    options : numpy array
        1D array of options for the RTE inversion. Default is np.asarray([6,15,0,0]) where 6 is the number of wavelengths, 15 is the max number of RTE iterations, 0 is the RTE inversion type (0 is RTE, 1 is CE+RTE, 2 is CE), 0 is the number of RTE iterations to run after CE+RTE inversion. (Not sure on last one)
    cavity_f : str
        path to cavity map file
    rows : slice
        slice of rows to invert, DEFAULT is slice(0,2048)
    cols : slice
        slice of columns to invert, DEFAULT is slice(0,2048)
    weight : numpy array
        1D array of weights for the RTE inversion. Default is np.asarray([1.,4.,5.4,4.1]) where 1 is Stokes I, 4 is Stokes Q, 5.4 is Stokes U, 4.1 is Stokes V. Based off noise levels in the respective Stokes parameters
    initial_model : numpy array
        1D array of initial model for the RTE inversion. Default is np.asarray([400,30,120,1,0.05,1.5,.01,.22,.85]) where 400 is the magnetic fields strength, 30 is the inclination, 120 is the azimuth, 1 is etha_0, 0.05 is lambda_doppler, 1.5 is AA, 0.01 is vlos, 0.22 is S_0, 0.85 is S_1

    Returns
    -------
    out : numpy array
        3D array of RTE inversion results with dimensions (y,x,r) where is the 12 RTE inversion outputs
        r from 0 to 11:
            Counter (PX Id)
            Iterations
            Strength
            Inclination
            Azimuth
            Eta0 parameter
            Doppler width
            Damping
            Los velocity
            Constant source function
            Slope source function
            Minimum chisqr value
    """
    print(" ")
    printc('-->>>>>>> RUNNING PYMILOS ',color=bcolors.OKGREEN)
    
    try:
        CMILOS_LOC = os.path.realpath(__file__)

        CMILOS_LOC = CMILOS_LOC.split('src/')[0] + 'pymilos/lib/' #-11 as hrt_pipe.py is 11 characters

        if os.path.isfile(CMILOS_LOC+'milos'):
            pass
        else:
            raise ValueError('Cannot find cmilos:', CMILOS_LOC)

    except ValueError as err:
        printc(err.args[0],color=bcolors.FAIL)
        printc(err.args[1],color=bcolors.FAIL)
        return        

    wavelength = 6173.3354

    start_time = time.perf_counter()

    if cpos == 0:
        shift_w =  wave_axis[3] - wavelength
    elif cpos == 5:
        shift_w =  wave_axis[2] - wavelength
    # DC TEST
    wave_axis = wave_axis - shift_w

    print('It is assumed the wavelength array is given by the hdr')
    print("Wave axis is: ", (wave_axis - wavelength)*1000.)
    print('Saving data into dummy_in.txt for RTE input')

    if data.ndim == 4:
        sdata = data
    elif data.ndim != 4:
        print("Incorrect dimensions of 'data' array")
        exit()
    y,x,p,l = sdata.shape
    
    if rte == 'RTE':
        options[2] = 0
    if rte == 'CE':
        options[2] = 2
    if rte == 'CE+RTE':
        options[2] = 1
    
    if cavity_f is not None:
        printc("  ---- >>>>> Correcting wavelengths for Cavity Maps shifts: .... ",color=bcolors.OKGREEN)
        wave_axis_2d = cavity_shifts(cavity_f,wave_axis,rows,cols)
        out = np.zeros((y,x,12))
        printc(f'  ---- >>>>> Inverting data: .... ',color=bcolors.OKGREEN)
        for i in range(y):
            for j in range(x):
                out[i,j] = pymilos.pmilos(options,sdata[i,j],wave_axis_2d[i,j],weight,initial_model)
        
    else:
        printc(f'  ---- >>>>> Inverting data: .... ',color=bcolors.OKGREEN)
        out = pymilos.pmilos(options,sdata,wave_axis,weight,initial_model)
    
    printc(f"CMILOS RTE Inversion Run Time: {np.round(time.perf_counter() - start_time,3)} seconds ",bcolors.OKGREEN)
    
    return out

def py_cmilos(data_f, hdr_arr, wve_axis_arr, data_shape, cpos_arr, data, rte, mask, imgdirx_flipped, out_rte_filename, out_dir, cavity_f = None, rows = slice(0,2048), cols = slice(0,2048), weight=np.asarray([1.,4.,5.4,4.1]), initial_model=np.asarray([400,30,120,1,0.05,1.5,.01,.22,.85]), vers = '01'):
    """Pre-process each scan and call `run_pymilos` for each scan in the data set.
    
    Parameters
    ----------
    data_f : list
        List of file paths to the data files.
    hdr_arr : list
        List of header information for each scan.
    wve_axis_arr : list or ndarray
        List of wavelength axis for each scan.
    data_shape : tuple
        Shape of the data array.
    cpos_arr : list
        List of the continuum position for each scan.
    data : ndarray
        Data array.
    rte : str
        RTE inversion type. Options are 'RTE', 'CE', 'CE+RTE'. 'RTE' is Radiative Transfer Equation inversion, 'CE' is Classical Estimates, 'CE+RTE' is Classical Estimates as initial for Radiative Transfer Equation inversion.
    mask : ndarray
        Mask array.
    imgdirx_flipped : bool
        If True, the image is flipped in the x-direction.
    out_rte_filename : str
        Name of the output file. For standard generated files, set to None
    out_dir : str
        Path to the output directory.
    cavity_f : str, optional
        Path to the cavity file. If None, no cavity correction is applied. The default is None.
    rows : slice, optional
        Rows to be used in the inversion. The default is slice(0,2048).
    cols : slice, optional
        Columns to be used in the inversion. The default is slice(0,2048).
    weight : ndarray, optional
        Weights for the inversion. The default is np.asarray([1.,4.,5.4,4.1]). See `run_pymilos` for more information.
    initial_model : ndarray, optional
        Initial model for the inversion. The default is np.asarray([400,30,120,1,0.05,1.5,.01,.22,.85]). See `run_pymilos` for more information.

    Returns
    -------
    None.
    """
    for scan in range(int(data_shape[-1])):
        printc(f'  ---- >>>>> Data scan number: {scan} .... ',color=bcolors.OKGREEN)
        
        start_time = time.perf_counter()

        file_path = data_f[scan]
        wave_axis = wve_axis_arr[scan]
        hdr_scan = hdr_arr[scan]
        
        if data.ndim == 5:
            sdata = data[:,:,:,:,scan]
        elif data.ndim > 5 or data.ndim < 4:
            print("Incorrect dimensions of 'data' array")
            exit()
        elif data.ndim == 4:
            sdata = data       
        
        options = np.asarray([6,15,0,0]) # # of wavelegths, # of iterations
        
        rte_invs = run_pymilos(sdata,wave_axis,rte,cpos_arr[0],options,cavity_f,rows,cols,weight,initial_model)
        rte_invs = np.moveaxis(rte_invs,-1,0)

        rte_invs_noth = np.copy(rte_invs)

        """
        From 0 to 11
        Counter (PX Id)
        Iterations
        Strength
        Inclination
        Azimuth
        Eta0 parameter
        Doppler width
        Damping
        Los velocity
        Constant source function
        Slope source function
        Minimum chisqr value
        """

        noise_in_V =  np.mean(sdata[:,:,3,cpos_arr[0]]) #ellipsis in case data has 4 dimensions
        low_values_flags = np.max(np.abs(sdata[:,:,3,:]),axis=-1) < noise_in_V  # Where values are low
        
        del sdata

        rte_invs[2,low_values_flags] = 0
        rte_invs[3,low_values_flags] = 0
        rte_invs[4,low_values_flags] = 0

        rte_data_products = np.zeros((7,rte_invs_noth.shape[1],rte_invs_noth.shape[2]))

        rte_data_products[0,:,:] = rte_invs_noth[9,:,:] + rte_invs_noth[10,:,:] #continuum
        rte_data_products[1,:,:] = rte_invs_noth[2,:,:] #b mag strength
        rte_data_products[2,:,:] = rte_invs_noth[3,:,:] #inclination
        rte_data_products[3,:,:] = rte_invs_noth[4,:,:] #azimuth
        rte_data_products[4,:,:] = rte_invs_noth[8,:,:] #vlos
        rte_data_products[5,:,:] = rte_invs_noth[2,:,:]*np.cos(rte_invs_noth[3,:,:]*np.pi/180.) #blos
        rte_data_products[6,:,:] = rte_invs_noth[11,:,:] #chisq

        rte_data_products *= mask[np.newaxis, :, :, scan] #field stop, set outside to 0

        hdr_scan['RTE_MOD'] = rte
        hdr_scan['RTE_SW'] = 'cmilos'
        hdr_scan['RTE_ITER'] = str(15)

        write_output_inversion(rte_data_products, file_path, scan, hdr_scan, out_dir, out_rte_filename, vers)
            
        printc('--------------------------------------------------------------',bcolors.OKGREEN)
        printc(f"------------- CMILOS RTE Run Time: {np.round(time.perf_counter() - start_time,3)} seconds ",bcolors.OKGREEN)
        printc('--------------------------------------------------------------',bcolors.OKGREEN)


def cmilos_fits(data_f, hdr_arr, wve_axis_arr, data_shape, cpos_arr, data, rte, mask, imgdirx_flipped, out_rte_filename, out_dir, vers = '01'):
    """RTE inversion using CMILOS, writing the input file for CMILOS out in fits format, slightly faster than standard CMILOS, but the CMILOS-FITS code is not as well tested as the standard CMILOS code. Has differences to CMILOS that are not fully understood. Please use standard CMILOS if possible.

    Parameters
    ----------
    data_f : str
        File path to the data
    hdr_arr : list or ndarray
        List of header information for each scan
    wve_axis_arr : list or ndarray
        List of wavelength axis for each scan
    data_shape : tuple
        Shape of the data
    cpos_arr : list or ndarray
        List of continuum positions for each scan
    data : ndarray
        Data array (y,x,p,l) or (y,x,p,l,scan)
    rte : str
        RTE inversion method to use, 'CE' or 'RTE' or 'CE+RTE'. 'RTE' is Radiative Transfer Equation inversion, 'CE' is Classical Estimates, 'CE+RTE' is Classical Estimates as initial for Radiative Transfer Equation inversion.
    mask : ndarray
        Mask array (y,x,scan)
    imgdirx_flipped : ndarray
        Flipped image direction array (y,x,scan)
    out_rte_filename : str
        Output filename for the RTE inversion, if None, standard filename is generated
    out_dir : str
        Output directory for the RTE inversion
    vers : str, optional
        Version number for the output file, by default '01'
    
    Returns
    -------
    None
    """
    print(" ")
    printc('-->>>>>>> RUNNING CMILOS ',color=bcolors.OKGREEN)
    
    try:
        CMILOS_LOC = os.path.realpath(__file__)

        CMILOS_LOC = CMILOS_LOC.split('src/')[0] + 'cmilos-fits/' #-11 as hrt_pipe.py is 11 characters

        if os.path.isfile(CMILOS_LOC+'milos'):
            printc("Cmilos-fits executable located at:", CMILOS_LOC,color=bcolors.WARNING)

        else:
            raise ValueError('Cannot find cmilos-fits:', CMILOS_LOC)

    except ValueError as err:
        printc(err.args[0],color=bcolors.FAIL)
        printc(err.args[1],color=bcolors.FAIL)
        return        

    wavelength = 6173.3354

    for scan in range(int(data_shape[-1])):

        start_time = time.perf_counter()

        file_path = data_f[scan]
        wave_axis = wve_axis_arr[scan]
        hdr_scan = hdr_arr[scan] # DC 20211117

        #must invert each scan independently, as cmilos only takes in one dataset at a time

        #get wave_axis from the hdr information of the science scans
        if cpos_arr[0] == 0:
            shift_w =  wave_axis[3] - wavelength
        elif cpos_arr[0] == 5:
            shift_w =  wave_axis[2] - wavelength

        wave_axis = wave_axis - shift_w

        print('It is assumed the wavelength array is given by the hdr')
        #print(wave_axis,color = bcolors.WARNING)
        print("Wave axis is: ", (wave_axis - wavelength)*1000.)
        print('Saving data into dummy_in.txt for RTE input')

        if data.ndim == 5:
            sdata = data[:,:,:,:,scan]
        elif data.ndim > 5 or data.ndim < 4:
            print("Incorrect dimensions of 'data' array")
            exit()
        elif data.ndim == 4:
            sdata = data
        y,x,p,l = sdata.shape

        #create hdr with wavelength positions
        hdr = fits.Header()
        print(wave_axis[0])
        hdr['LAMBDA0'] = wave_axis[0]#needs it in Angstrom 6173.1 etc
        hdr['LAMBDA1'] = wave_axis[1]
        hdr['LAMBDA2'] = wave_axis[2]
        hdr['LAMBDA3'] = wave_axis[3]
        hdr['LAMBDA4'] = wave_axis[4]
        hdr['LAMBDA5'] = wave_axis[5]
        
        #write out data to temp fits for cmilos-fits input
        input_arr = np.transpose(sdata, axes = (3,2,0,1)) #must transpose due to cfitsio (wl,pol,y,x) #3201 originally
        hdu1 = fits.PrimaryHDU(data=input_arr, header = hdr)

        #mask
        mask = np.ones((sdata.shape[0],sdata.shape[1])) #change this for fdt
        hdu2 = fits.ImageHDU(data=mask)

        #write out to temp fits
        hdul_tmp = fits.HDUList([hdu1, hdu2])
        hdul_tmp.writeto(out_dir+'temp_cmilos_io.fits', overwrite=True)

        printc(f'  ---- >>>>> Inverting data scan number: {scan} .... ',color=bcolors.OKGREEN)

        cmd = CMILOS_LOC+"milos"
        #cmd = fix
        #fix_path(cmd)
        print(cmd)

        if rte == 'RTE':
            rte_on = subprocess.call(cmd+f" 6 15 0 {out_dir+'temp_cmilos_io.fits'}",shell=True)
        if rte == 'CE':
            rte_on = subprocess.call(cmd+f" 6 15 2 {out_dir+'temp_cmilos_io.fits'}",shell=True)
        if rte == 'CE+RTE':
            rte_on = subprocess.call(cmd+f" 6 15 1 {out_dir+'temp_cmilos_io.fits'}",shell=True)

        print(rte_on)

        printc('  ---- >>>>> Reading results.... ',color=bcolors.OKGREEN)
        #print(del_dummy)

        with fits.open(out_dir+'temp_cmilos_io.fits') as hdu_list:
            rte_out = hdu_list[0].data
            #hdu_list.writeto(out_dir+'rte_out.fits', overwrite=True)
        
        del input_arr

        """
        From 0 to 11
        Iterations
        Strength
        Inclination
        Azimuth
        Eta0 parameter
        Doppler width
        Damping/aa
        Los velocity
        alfa? Counter PID?
        Constant source function
        Slope source function
        Minimum chisqr value

        Direct from cmilos-fits/milos.c
        inv->iter = malloc(npix*sizeof(int));
        inv->B    = malloc(npix*sizeof(double));
        inv->gm   = malloc(npix*sizeof(double));
        inv->az   = malloc(npix*sizeof(double));
        inv->eta0 = malloc(npix*sizeof(double));
        inv->dopp = malloc(npix*sizeof(double));
        inv->aa   = malloc(npix*sizeof(double));
        inv->vlos = malloc(npix*sizeof(double)); //km/s
        inv->alfa = malloc(npix*sizeof(double)); //stay light factor
        inv->S0   = malloc(npix*sizeof(double));
        inv->S1   = malloc(npix*sizeof(double));
        inv->nchisqrf = malloc(npix*sizeof(double));
        """
        noise_in_V =  np.mean(sdata[:,:,3,cpos_arr[0]])
        low_values_flags = np.max(np.abs(sdata[:,:,3,:]),axis=-1) < noise_in_V  # Where values are low
        
        rte_out[2,low_values_flags] = 0 #not sure about 2,3,4 indexing here
        rte_out[3,low_values_flags] = 0
        rte_out[4,low_values_flags] = 0
        
       
        rte_data_products = np.zeros((7,rte_out.shape[1],rte_out.shape[2]))

        rte_data_products[0,:,:] = rte_out[9,:,:] + rte_out[10,:,:] #continuum
        rte_data_products[1,:,:] = rte_out[1,:,:] #b mag strength
        rte_data_products[2,:,:] = rte_out[2,:,:] #inclination
        rte_data_products[3,:,:] = rte_out[3,:,:] #azimuth
        rte_data_products[4,:,:] = rte_out[7,:,:] #vlos
        rte_data_products[5,:,:] = rte_out[1,:,:]*np.cos(rte_out[2,:,:]*np.pi/180.) #blos
        rte_data_products[6,:,:] = rte_out[11,:,:] #chisq

        rte_data_products *= mask[np.newaxis, :, :, scan] #field stop, set outside to 0

        hdr_scan['RTE_MOD'] = rte
        hdr_scan['RTE_SW'] = 'cmilos-fits'
        hdr_scan['RTE_ITER'] = str(15)

        write_output_inversion(rte_data_products, file_path, scan, hdr_scan, out_dir, out_rte_filename, vers)

        printc('--------------------------------------------------------------',bcolors.OKGREEN)
        printc(f"------------- CMILOS-FITS RTE Run Time: {np.round(time.perf_counter() - start_time,3)} seconds ",bcolors.OKGREEN)
        printc('--------------------------------------------------------------',bcolors.OKGREEN)



def pmilos_not_working(data_f, hdr_arr, wve_axis_arr, data_shape, cpos_arr, data, rte, mask, imgdirx_flipped, out_rte_filename, out_dir, vers = '01'):
    """
    RTE inversion using PMILOS, not working - IGNORE
    """
    print(" ")
    printc('-->>>>>>> RUNNING PMILOS ',color=bcolors.OKGREEN)
    
    try:
        PMILOS_LOC = os.path.realpath(__file__)

        PMILOS_LOC = PMILOS_LOC.split('src/')[0] + 'p-milos/' #11 as hrt_pipe.py is 11 characters -8 if in utils.py

        if os.path.isfile(PMILOS_LOC+'pmilos.x'):
            printc("Pmilos executable located at:", PMILOS_LOC,color=bcolors.WARNING)

        else:
            raise ValueError('Cannot find pmilos:', PMILOS_LOC)

    except ValueError as err:
        printc(err.args[0],color=bcolors.FAIL)
        printc(err.args[1],color=bcolors.FAIL)
        return  
    
    wavelength = 6173.3354

    for scan in range(int(data_shape[-1])):

        start_time = time.perf_counter()

        file_path = data_f[scan]
        wave_axis = wve_axis_arr[scan]
        hdr_scan = hdr_arr[scan]

        #must invert each scan independently, as cmilos only takes in one dataset at a time

        #get wave_axis from the hdr information of the science scans
        if cpos_arr[0] == 0:
            shift_w =  wave_axis[3] - wavelength
        elif cpos_arr[0] == 5:
            shift_w =  wave_axis[2] - wavelength

        wave_axis = wave_axis - shift_w

        print('It is assumed the wavelength array is given by the hdr')
        #print(wave_axis,color = bcolors.WARNING)
        print("Wave axis is: ", (wave_axis - wavelength)*1000.)
        print('Saving data into ./p-milos/run/data/input_tmp.fits for pmilos RTE input')

        #write wavelengths to wavelength.fits file for the settings

        wave_input = np.zeros((2,6)) #cfitsio reads dimensions in opposite order
        wave_input[0,:] = 1
        wave_input[1,:] = wave_axis

        print(wave_axis)

        if data.ndim == 5:
            sdata = data[:,:,:,:,scan]
        elif data.ndim > 5 or data.ndim < 4:
            print("Incorrect dimensions of 'data' array")
            exit()
        elif data.ndim == 4:
            sdata = data

        hdr = fits.Header()

        primary_hdu = fits.PrimaryHDU(wave_input, header = hdr)
        hdul = fits.HDUList([primary_hdu])
        hdul.writeto(f'./p-milos/run/wavelength_tmp.fits', overwrite=True)

        sdata = sdata.T
        sdata = sdata.astype(np.float32)
        #create input fits file for pmilos
        hdr = fits.Header() 
        
        hdr['CTYPE1'] = 'HPLT-TAN'
        hdr['CTYPE2'] = 'HPLN-TAN'
        hdr['CTYPE3'] = 'STOKES' #check order of stokes
        hdr['CTYPE4'] = 'WAVE-GRI' 
    
        primary_hdu = fits.PrimaryHDU(sdata, header = hdr)
        hdul = fits.HDUList([primary_hdu])
        hdul.writeto(PMILOS_LOC+f'run/data/input_tmp.fits', overwrite=True)

        if rte == 'RTE':
            cmd = "mpiexec -n 64 "+PMILOS_LOC+"pmilos.x pmilos.minit" #../milos.x pmilos.mtrol" ##
        
        if rte == 'CE':
            cmd = "mpiexec -np 16 "+PMILOS_LOC+"pmilos.x pmilos_ce.minit"

        if rte == 'CE+RTE':
            print("CE+RTE not possible on PMILOS, performing RTE instead")
            cmd = "mpiexec -np 16 "+PMILOS_LOC+"pmilos.x pmilos.minit"

        if rte == 'RTE_seq':
            cmd = PMILOS_LOC+"milos.x pmilos.mtrol"

        del sdata
        #need to change settings for CE or CE+RTE in the pmilos.minit file here
        
        printc(f'  ---- >>>>> Inverting data scan number: {scan} .... ',color=bcolors.OKGREEN)

        cwd = os.getcwd()
        os.chdir("./p-milos/run/")
        rte_on = subprocess.call(cmd,shell=True)
        os.chdir(cwd)
        
        if rte == 'CE':
            out_file = 'inv__mod_ce.fits' # not sure about this one

        else:
            out_file = 'inv__mod.fits' #only when one datacube and 16 processors

        with fits.open(PMILOS_LOC+f'run/results/{out_file}') as hdu_list:
            result = hdu_list[0].data

        #del_dummy = subprocess.call(f"rm ./p-milos/run/results/{out_file}.fits",shell=True) 
        del_dummy = subprocess.call(f"rm "+PMILOS_LOC+"run/results/{out_file}",shell=True) #must delete the output file
      
        #result has dimensions [rows,cols,13]
        result = np.moveaxis(result,0,2)
        print(result.shape)
        #printc(f'  ---- >>>>> You are HERE .... ',color=bcolors.WARNING)
        """
        PMILOS Output 13 columns
        0. eta0 = line-to-continuum absorption coefficient ratio 
        1. B = magnetic field strength [Gauss] 
        2. vlos = line-of-sight velocity [km/s] 
        3. dopp = Doppler width [Angstroms] 
        4. aa = damping parameter 
        5. gm = magnetic field inclination [deg] 
        6. az = magnetic field azimuth [deg] 
        7. S0 = source function constant 
        8. S1 = source function gradient 
        9. mac = macroturbulent velocity [km/s] 
        10. filling factor of the magnetic component [0-1]  
        11. Number of iterations performed 
        12. Chisqr value
        """

        rte_data_products = np.zeros((7,result.shape[0],result.shape[1]))

        rte_data_products[0,:,:] = result[:,:,7] + result[:,:,8] #continuum
        rte_data_products[1,:,:] = result[:,:,1] #b mag strength
        rte_data_products[2,:,:] = result[:,:,5] #inclination
        rte_data_products[3,:,:] = result[:,:,6] #azimuth
        rte_data_products[4,:,:] = result[:,:,2] #vlos
        rte_data_products[5,:,:] = result[:,:,1]*np.cos(result[:,:,5]*np.pi/180.) #blos
        rte_data_products[5,:,:] = result[:,:,12] #chisq

        rte_data_products *= mask[np.newaxis, :, :, scan] #field stop, set outside to 0

        hdr_scan['RTE_MOD'] = rte
        hdr_scan['RTE_SW'] = 'pmilos'
        hdr_scan['RTE_ITER'] = str(15)

    write_output_inversion(rte_data_products, file_path, scan, hdr_scan, out_dir, out_rte_filename, vers)

    printc('--------------------------------------------------------------',bcolors.OKGREEN)
    printc(f"------------- PMILOS RTE Run Time: {np.round(time.perf_counter() - start_time,3)} seconds ",bcolors.OKGREEN)
    printc('--------------------------------------------------------------',bcolors.OKGREEN)

